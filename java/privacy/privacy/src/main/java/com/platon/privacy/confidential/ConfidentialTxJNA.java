package com.platon.privacy.confidential;

public class ConfidentialTxJNA {

    /**
     * Create a confidential tx.
     *
     * <p>In: tx_json: a pointer to tx json string. In: tx_len: the size of tx json string. Out:
     * error: output a ExternError. 'code' 0 represents success, all other values represent failure.
     * If the `code` field is nonzero, there should always be a message, and if it's zero, the
     * message will always be null.
     *
     * <p>Returns: if success, return pointer and len of tx. Otherwise return null.
     */
    public static byte[] create_confidential_tx(byte[] tx_json, int tx_len) throws Exception {
        ExternError error = new ExternError();
        ByteBuffer.ByValue value =
                ConfidentialLibrary.INSTANCE.create_confidential_tx(tx_json, tx_len, error);
        return checkResult(error, value);
    }

    public static byte[] create_confidential_tx(byte[] tx_json) throws Exception {
        return create_confidential_tx(tx_json, tx_json.length);
    }

    /**
     * Create a confidential tx.
     *
     * <p>In: tx_json: a pointer to tx rlp stream. In: tx_len: the size of tx rlp stream. Out:
     * error: output a ExternError. 'code' 0 represents success, all other values represent failure.
     * If the `code` field is nonzero, there should always be a message, and if it's zero, the
     * message will always be null.
     *
     * <p>Returns: if success, return pointer and len of tx. Otherwise return null.
     */
    public static byte[] create_confidential_tx_by_rlp(byte[] data, int data_len) throws Exception {
        ExternError error = new ExternError();
        ByteBuffer.ByValue value =
                ConfidentialLibrary.INSTANCE.create_confidential_tx_by_rlp(data, data_len, error);
        return checkResult(error, value);
    }

    public static byte[] create_confidential_tx_by_rlp(byte[] data) throws Exception {
        return create_confidential_tx_by_rlp(data, data.length);
    }
    /**
     * Verify the confidential tx.
     *
     * <p>In: tx_data: a pointer to tx string generated by 'create_confidential_tx'. In: tx_len: the
     * size of tx string. Out: error: output a ExternError. 'code' 0 represents success, all other
     * values represent failure. If the `code` field is nonzero, there should always be a message,
     * and if it's zero, the message will always be null.
     *
     * <p>Returns: if success, return pointer and len of tx log. Otherwise return null.
     */
    public static byte[] confidential_tx_verify(byte[] tx_data, int tx_len) throws Exception {
        ExternError error = new ExternError();
        ByteBuffer.ByValue value =
                ConfidentialLibrary.INSTANCE.confidential_tx_verify(tx_data, tx_len, error);
        return checkResult(error, value);
    }

    public static byte[] confidential_tx_verify(byte[] tx_data) throws Exception {
        return confidential_tx_verify(tx_data, tx_data.length);
    }
    /**
     * Create a key pair for view key and spend key.
     *
     * <p>Note: if sk_data is null or sk_len is 0, 'create_keypair' will output a random key pair.
     *
     * <p>In: sk_data: a pointer to sk string of "user's input". In: sk_len: the size of sk string.
     * Out: error: output a ExternError. 'code' 0 represents success, all other values represent
     * failure. If the `code` field is nonzero, there should always be a message, and if it's zero,
     * the message will always be null.
     *
     * <p>Returns: if success, return pointer and len of key pair json string. Otherwise return
     * null.
     *
     * <p>The output key pair format is rlp encoding.
     */
    public static byte[] create_keypair(byte[] sk_data, int sk_len) throws Exception {
        ExternError error = new ExternError();
        ByteBuffer.ByValue value =
                ConfidentialLibrary.INSTANCE.create_keypair(sk_data, sk_len, error);
        return checkResult(error, value);
    }

    /**
     * Is the owner of note.
     *
     * <p>In: ephemeral_pk_data: a pointer to ephemeral_pk. In: ephemeral_pk_len: the size of
     * ephemeral_pk. In: sign_pk_data: a pointer to sign_pk. In: sign_pk_len: the size of sign_pk.
     * In: view_sk_data: a pointer to view_sk. In: view_sk_len: the size of view_sk. Out: error:
     * output a ExternError. 'code' 0 represents success, it is the correct owner. All other values
     * represent failure. If the `code` field is nonzero, there should always be a message, and if
     * it's zero, the message will always be null.
     */
    public static boolean is_note_owner(
            byte[] ephemeral_pk_data,
            int ephemeral_pk_len,
            byte[] sign_pk_data,
            int sign_pk_len,
            byte[] spend_pk_data,
            int spend_pk_len,
            byte[] view_sk_data,
            int view_sk_len) throws Exception {
        ExternError error = new ExternError();
        ConfidentialLibrary.INSTANCE.is_note_owner(
                ephemeral_pk_data,
                ephemeral_pk_len,
                sign_pk_data,
                sign_pk_len,
                spend_pk_data,
                spend_pk_len,
                view_sk_data,
                view_sk_len,
                error);
        if (0 == error.code) return true;
        if (0 != error.code) {
            String errorMessage = error.message.getString(0);
            ConfidentialLibrary.INSTANCE.confidential_tx_destroy_string(error.message);
            throw new Exception(errorMessage);
        }
        return false;
    }

    /**
     * Decrypt the quatity and blinding.
     *
     * <p>In: cipher_data: a pointer to ephemeral_pk. In: cipher_len: the size of ephemeral_pk. In:
     * view_sk_data: a pointer to view_sk. In: view_sk_len: the size of view_sk. Out: error: output
     * a ExternError. 'code' 0 represents success, all other values represent failure. If the `code`
     * field is nonzero, there should always be a message, and if it's zero, the message will always
     * be null.
     *
     * <p>Returns: if success, return pointer and len of quatity and blinding. Otherwise return
     * null. Using the rlp encoding of quatity and blinding.
     */
    public static byte[] decrypt_note (
            byte[] cipher_data, int cipher_len, byte[] view_sk_data, int view_sk_len) throws Exception {
        ExternError error = new ExternError();
        ByteBuffer.ByValue value =
                ConfidentialLibrary.INSTANCE.decrypt_note(
                        cipher_data, cipher_len, view_sk_data, view_sk_len, error);
        return checkResult(error, value);
    }

    public static byte[] decrypt_note(byte[] cipher_data, byte[] view_sk_data) throws Exception {
        return decrypt_note(cipher_data, cipher_data.length, view_sk_data, view_sk_data.length);
    }

    private static byte[] checkResult(ExternError error, ByteBuffer.ByValue value) throws Exception {
        if (error.code != 0) {
            String errorMessage = error.message.getString(0);
            ConfidentialLibrary.INSTANCE.confidential_tx_destroy_string(error.message);
            ConfidentialLibrary.INSTANCE.confidential_tx_destroy_bytebuffer(value);
            throw new Exception(errorMessage);
        }

        byte[] resultBytes = value.data.getByteArray(0, (int) value.len);
        ConfidentialLibrary.INSTANCE.confidential_tx_destroy_bytebuffer(value);

        return resultBytes;
    }
}
